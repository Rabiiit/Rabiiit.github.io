<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    

    <title>SDWebImage解析 | </title>
    <meta name="author" content="John Doe">
    
    <meta name="description" content="SDWebImage是开发中常用的网络加载图片的库，使用频率高到令人发指。本身优秀的接口封装和底层的内存管理都让开发者免去了很多麻烦，那么作为一个开发者，有必要对这么一个每天都要打交道的库有一些更深入的了解。这里我记录下自己阅读源码的心得，算是做个笔记。
12345sd_setImageWithUR">
    
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta property="og:title" content="SDWebImage解析"/>
    <meta property="og:site_name" content="Hexo"/>

    
    <meta property="og:image" content="undefined"/>
    

    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    <link rel="stylesheet" href="/css/lib/materialize.min.css">
    <link rel="stylesheet" href="/css/lib/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

    
        <link rel="stylesheet" href="/css/lib/prettify-tomorrow-night-eighties.css" type="text/css">
    
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
    <img src="/weixin_favicon.png" style="position: absolute; left: -9999px; opacity: 0; filter: alpha(opacity=0);">

    <nav class="indigo">
    <div class="nav-wrapper">
        <a href="#" data-activates="main-menu" class="button-collapse">
            <i class="fa fa-navicon"></i>
        </a>
        <div class="">
            <a href="/" class="brand-logo hide-on-med-and-down">Hexo</a>
            <ul class="right hide-on-med-and-down">
                
                    <li>
                        <a class="menu-home " href="/" >
                            <i class="fa fa-home "></i>
                            
                            Home
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-archive " href="/archives" >
                            <i class="fa fa-archive "></i>
                            
                            Archives
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                            <i class="fa fa-bookmark "></i>
                            
                            Categories
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-reading " href="/reading" >
                            <i class="fa fa-book "></i>
                            
                            Reading
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-about " href="/about" >
                            <i class="fa fa-user "></i>
                            
                            About
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-search modal-trigger " href="#search" >
                            <i class="fa fa-search "></i>
                            
                            Search
                        </a>
                    </li>
                
            </ul>
            <div>
    <ul class="side-nav indigo darken-1" id="main-menu">
        
        <li class="side-user">
            <div class="row">
                <div class="col s4 no-padding">
                    <img class="avatar-image circle responsive-img" src="http://ww2.sinaimg.cn/small/74990035jw1f1rjkd681bj20rs0rsdhg.jpg" alt="User Avatar">
                </div>
                <div class="info col s8 valign-wrapper no-padding">
                    <div class="valign">
                        <p class="name">你的大名</p>
                        <p class="desc">Web前端/iOS/技术宅</p>
                    </div>
                </div>
            </div>
        </li>
        

        
            <li class="no-padding">
                <a class="waves-effect menu-home " href="/" >
                    <i class="fa fa-home "></i>
                    
                    Home
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-archive " href="/archives" >
                    <i class="fa fa-archive "></i>
                    
                    Archives
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                    <i class="fa fa-bookmark "></i>
                    
                    Categories
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-reading " href="/reading" >
                    <i class="fa fa-book "></i>
                    
                    Reading
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-about " href="/about" >
                    <i class="fa fa-user "></i>
                    
                    About
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-search modal-trigger " href="#search" >
                    <i class="fa fa-search "></i>
                    
                    Search
                </a>
            </li>
        
    </ul>

    <ul class="side-nav indigo darken-1" id="category-menu">
    

            

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/网络/">
                    网络 <span class="right">5</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/系统/">
                    系统 <span class="right">2</span></a>
                </a>
            </li>

        

    </ul>
</div>

        </div>
    </div>
</nav>

<div id="search" class="modal search-modal">
    <div class="row">
        <div class="input-field col s12">
              <input id="search-input" type="text">
              <label for="search-input">Search</label>
        </div>

    </div>
    <div id="search-result" class="search-result col s12">

    </div>
</div>


    <main>
        <div class="container main-container">
    <nav class="page-nav hide-on-small-only">
    <div class="nav-wrapper indigo">
        <span class="breadcrumb">Current page(Categories)</span>
        
            
    
    
    <a class="breadcrumb" href="/categories/网络/">网络</a>


        

        
    </div>
</nav>

<article>
    <div class="card">
        <div class="card-content">
            

            <div class="article-title">
                
    
        <h1>SDWebImage解析</h1>
    


            </div>
            <time class="pink-link-context" datetime="2017-07-02T04:00:00.000Z"><a href="/2017/07/02/SDWebImage解析/">2017-07-02</a></time>

            <span id="busuanzi_container_page_pv" class="read-times-container">
    <i class="fa fa-eye"></i>
    <span id="busuanzi_value_page_pv"></span>
</span>

            
    <div class="tags-row">
        
            <a href="/tags/源码解析/" class="chip pink lighten-1">源码解析</a>
        
    </div>


            <div class="toc pink-link-context hide-on-med-and-down">
    <ol class="section table-of-contents"><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#补充说明：NSURLCache的执行策略"><span class="section table-of-contents-text">补充说明：NSURLCache的执行策略</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#总结SDWebImage的流程"><span class="section table-of-contents-text">总结SDWebImage的流程</span></a></li></ol>
</div>


            <div class="entry pink-link-context">
                <p>SDWebImage是开发中常用的网络加载图片的库，使用频率高到令人发指。本身优秀的接口封装和底层的内存管理都让开发者免去了很多麻烦，那么作为一个开发者，有必要对这么一个每天都要打交道的库有一些更深入的了解。这里我记录下自己阅读源码的心得，算是做个笔记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock</div></pre></td></tr></table></figure>
<p>而这个方法里面是直接调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sd_internalSetImageWithURL:(nullable NSURL *)url</div><div class="line">                  placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(nullable NSString *)operationKey</div><div class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</div></pre></td></tr></table></figure></p>
<p>这个方法首先第一步就是检测是否用了相同的请求，在UIView的webCacheOperation category中，实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</div><div class="line">    // Cancel in progress downloader from queue</div><div class="line">    SDOperationsDictionary *operationDictionary = [self operationDictionary];</div><div class="line">    id operations = operationDictionary[key];</div><div class="line">    if (operations) &#123;</div><div class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</div><div class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</div><div class="line">                if (operation) &#123;</div><div class="line">                    [operation cancel];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</div><div class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</div><div class="line">        &#125;</div><div class="line">        [operationDictionary removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看看这个方法，SDOperationDictionary是一个普通的dictionary，当一个UIView或者其子类调用webCacheOperation方法的时候会为其延迟加载一个dictionary，由于这个property只会在运行时声明和调用，所以这里采取objc_getAssociatedObject 关联对象的方法，对于每个UIView，如果要使用SDOperationDictionary这个property,那么会在需要的时候调用。实际上整个框架里的操作都是通过一个operationDictionary来管理，添加到VIView上可以使任何UIView的子类可以直接绑定对应的operationDictionary。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (SDOperationsDictionary *)operationDictionary &#123;</div><div class="line">    SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);</div><div class="line">    if (operations) &#123;</div><div class="line">        return operations;</div><div class="line">    &#125;</div><div class="line">    operations = [NSMutableDictionary dictionary];</div><div class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    return operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法为UIView动态添加一个property。<br>回到sd_cancelImageLoadOperationWithKey方法，从这个dictionary中取出对应key的元素，如果是数组则每一个都取消，否则直接取消（前提是实现SDWebImageOperation这个协议）这样的话当开启一个新的操作的时候不会被前面的操作所影响。</p>
<p>取消之后，首先如果需要的话（SDWebImageOption 这个flag中没有选择 SDWebImageDelayPlaceholder）在主线程中使用placeholder图片来暂时占据发起图片加载请求的UIView（通常为nil，但是如果有选择的话其实可以预加载图片，在还没有完成真正的图片加载之前先占据视图以免为空白或者仍为旧图片）</p>
<p>之后进入正式的加载图片的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">if (url) &#123;</div><div class="line">        // check if activityView is enabled or not</div><div class="line">        /* indicator 操作*/</div><div class="line">        </div><div class="line">        __weak __typeof(self)wself = self;</div><div class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</div><div class="line">            __strong __typeof (wself) sself = wself;</div><div class="line">            [sself sd_removeActivityIndicator];</div><div class="line">            if (!sself) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            dispatch_main_async_safe(^&#123;</div><div class="line">                if (!sself) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    return; // 通常情况下当图片加载完成之后就直接将其设置为UIImageView的图片，只要sdWebImageAvoidAutoSetImage这个flag设定被选择</div><div class="line">                &#125; else if (image) &#123;</div><div class="line">                    [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                    [sself sd_setNeedsLayout]; //这个方法其实直接调用setImageBlock,将image和data作为参数赋予block</div><div class="line">                &#125; else &#123;</div><div class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        [sself sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                        [sself sd_setNeedsLayout];// 特别情况，placeholder的赋予被手动延迟，在图片加载完成之后没有成功的情况下才实现</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;// 只有需要手动完成图片显示的情况下才需要在这里最终完成complete的调用</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        [self sd_setImageLoadOperation:operation forKey:validOperationKey]; // 将这个请求加入到operation的dictionary中</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            </div><div class="line">            if (completedBlock) &#123;</div><div class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</div><div class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面关键的部分我加入了一些注释，这是在取得了image &amp; data的情况下怎么样调用数据的处理。总的来说这个部分其实是完成三个功能：（1）创建一个新的operation指令对象 （2）赋予这个对象complete block （3）将请求加入UIView的opereation dictionary中</p>
<p>接下来先看如何创建一个operation对象，至于dictionary中的指令队列处理放到后面再说。<br>首先看看SDWebImageManager中对自己功能的描述：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>
<p>意为在UIImageView+WebCache背后，管理异步下载（SDWebImageDownloader）和图片缓存（SDImageCache）的类。实际上和它的名字本身是一样，是一个统合管理的类，构建起几个模块中间的桥梁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">// SDWebImageManager</div><div class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock&#123;</div><div class="line">                                       </div><div class="line">    /* 字符串处理 */</div><div class="line">                                       </div><div class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation; // 创建一个新的operation对象</div><div class="line">    </div><div class="line">    /* url合法性判断，长度不为0，不在记录的已失败队列中 */</div><div class="line">    </div><div class="line">    /* 为operation对象的NSOperation类property---cacheOperation赋值</div><div class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</div><div class="line">    </div><div class="line">        //* 如果需要重新更新图片cache */</div><div class="line">        重新从服务端获取新的数据，并根据SDWebImageDownloaderOptions来调整缓存策略</div><div class="line">        </div><div class="line">        // 创建operationToken对象</div><div class="line">        SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</div><div class="line">            /* 如果operation被取消了则什么都不干 */</div><div class="line">            </div><div class="line">            /* 如果error了则将url加入到failUrl数组中 */</div><div class="line">            if (   error.code != NSURLErrorNotConnectedToInternet</div><div class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</div><div class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</div><div class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</div><div class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</div><div class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</div><div class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost</div><div class="line">                        &amp;&amp; error.code != NSURLErrorNetworkConnectionLost) &#123;</div><div class="line">                        @synchronized (self.failedURLs) &#123;</div><div class="line">                            [self.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">            // 正常情况</div><div class="line">            if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</div><div class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                            // 当图片数据从网络端下载好之后， 如果delegate完成了图片转化的功能，那么会先将图片交由delegate进行一定的转换（编解码等处理）然后将得到的transformedImage进行缓存</div><div class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</div><div class="line">                            </div><div class="line">                            if (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                //缓存图片，如果是被改变过的，则将imageData置为nil，这样imageCache能够根据处理过的transformedImage来重新计算data</div><div class="line">                                [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // 如果不需要下载好的图像进行处理则直接缓存</div><div class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</div><div class="line">                        &#125;</div><div class="line">                        [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                    if (finished) &#123;</div><div class="line">                    [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                // 对operation的cancelBlock进行赋值</div><div class="line">                [self.imageDownloader cancel:subOperationToken];</div><div class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">                [self safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">            </div><div class="line">            </div><div class="line">        &#125;else if (cachedImage) &#123;</div><div class="line">            //已经缓存了图片的情况</div><div class="line">            __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</div><div class="line">            [self safelyRemoveOperationFromRunning:operation];</div><div class="line">        &#125; else &#123;</div><div class="line">            // 图片没有被缓存并且也不被允许下载</div><div class="line">            __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</div><div class="line">            [self safelyRemoveOperationFromRunning:operation];</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">              return operation;                     &#125;</div></pre></td></tr></table></figure>
<p>如上面的代码所示，SDWebImageManager中调用方法返回一个operation对象的过程大致是（1）创建一个SDWebImageCombinedOperation对象 （2）调用[self.imageCache queryCacheOperationForKey:key done:^(UIImage <em>cachedImage, NSData </em>cachedData, SDImageCacheType cacheType)方法赋值operation的cacheOperation，里面包含从网络获取图片的block以及对image数据预处理和缓存的指令(3)给operation的cancelBlock赋值<br>到这里我们就已经是在成功获取图片的前提下进行了一系列操作，大家其实都可以明白，由于是将回调block的形式进行调用，所以这里在底层执行的顺序其实和我们现在一步步查找代码的调用顺序是反过来的，下面才是真正拿到图片的重头戏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#SDWebImageDownloader</div><div class="line"></div><div class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __weak SDWebImageDownloader *wself = self;</div><div class="line"></div><div class="line">    // 直接调用了另一个方法，为下载操作添加回调的块</div><div class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        </div><div class="line">        /* 很多操作，后面再谈 */</div><div class="line">        </div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到是直接调用另一个方法的，那我们先看这个被调用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(nullable NSURL *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line">    // URL被用来作为字典的Key，所以一定不能为空，否则全部清空</div><div class="line">    if (url == nil) &#123;</div><div class="line">        if (completedBlock != nil) &#123;</div><div class="line">            completedBlock(nil, nil, nil, NO);</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 创建一个新的token</div><div class="line">    __block SDWebImageDownloadToken *token = nil;</div><div class="line"></div><div class="line">    </div><div class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</div><div class="line">        </div><div class="line">        // 从字典中取出对应url的operation</div><div class="line">        SDWebImageDownloaderOperation *operation = self.URLOperations[url];</div><div class="line">        if (!operation) &#123;</div><div class="line">        </div><div class="line">            // 如果不存在的话就初始化一个，并且设定comletionBlock:执行完成之后就把自己从字典中删掉（注意block中变量的使用方法防止retain loop,）需要注意的是，如果已经创建过operation就没有必要再进行一次这个操作了</div><div class="line">            operation = createCallback();</div><div class="line">            self.URLOperations[url] = operation;</div><div class="line"></div><div class="line">            __weak SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              if (!soperation) return;</div><div class="line">              if (self.URLOperations[url] == soperation) &#123;</div><div class="line">                  [self.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">        </div><div class="line">        // 将url和对应的operation生成的cancelToken作为参数，生成token并return</div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而上面可以看到，系统自己调用的createCallback是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">__weak SDWebImageDownloader *wself = self;</div><div class="line"></div><div class="line">// 真的直接调用addprogressCallBack方法</div><div class="line">return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">    __strong __typeof (wself) sself = wself;</div><div class="line">    NSTimeInterval timeoutInterval = sself.downloadTimeout;</div><div class="line">    if (timeoutInterval == 0.0) &#123;</div><div class="line">        timeoutInterval = 15.0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 为了禁止有可能出现的重复缓存（NSURLCache + SDImageCache）,这里默认禁用图片请求时加入的cache</div><div class="line">    // NSURLRequestCachePolicy 当URL加载系统处理一个请求时在缓存系统中采取的策略，这里的选项NSURLRequestReloadIgnoringLocalCacheData代表着从URL加载来的数据必须来自数据源头，不管是不是缓存了最新的数据，都不能直接将本地的缓存的图片数据当做请求的结果。</div><div class="line">    </div><div class="line">    // 默认情况</div><div class="line">    NSURLRequestCachePolicy cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;</div><div class="line">    </div><div class="line">    // 根据传入的option来改变缓存策略</div><div class="line">    if (options &amp; SDWebImageDownloaderUseNSURLCache) &#123;</div><div class="line">        if (options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">            cachePolicy = NSURLRequestReturnCacheDataDontLoad;</div><div class="line">        &#125; else &#123;</div><div class="line">            cachePolicy = NSURLRequestUseProtocolCachePolicy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 建立请求request</div><div class="line">    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];</div><div class="line">    </div><div class="line">    // request的参数设置</div><div class="line">    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">    request.HTTPShouldUsePipelining = YES;</div><div class="line">    // headersFilter这个block负责从一个大的httpheader字典中筛选出作为http request的header的字典，如果block为空就直接把loader类的httpheaders赋值给request</div><div class="line">    if (sself.headersFilter) &#123;</div><div class="line">        request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">    &#125;</div><div class="line">    SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">    operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">    </div><div class="line">    if (sself.urlCredential) &#123;</div><div class="line">        operation.credential = sself.urlCredential;</div><div class="line">    &#125; else if (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">        operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">        operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">    &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">        operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 最关键的，将请求加到downloadQueue里</div><div class="line">    [sself.downloadQueue addOperation:operation];</div><div class="line">    // 如果是LIFO策略就将这个请求调到最前面</div><div class="line">    if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">        // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</div><div class="line">        [sself.lastAddedOperation addDependency:operation];</div><div class="line">        sself.lastAddedOperation = operation;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>注意实际上调用的时候completion blocks执行的顺序其实和上面分析的顺序正好是反过来的，毕竟只有底层调用完成之后才能执行上一层的completion操作，而且也需要说明的是由于最底层的operation请求不是直接启用，而是加入到operationQueue中等待执行，所以所有的处理方法全部只能用block的形式封装起来进行传递。<br>整个框架在阅读起来比较麻烦，因为采用了太多的回调的形式，并且manager类联系所有其他功能类的这个结构，一开始没发现的话其实在不同类中跳来跳去十分繁琐。但是一但了解这种设计模式，是十分有好处的，并且框架中大量使用的block语法和多线程编程，十分精彩。阅读这个框架的源码确实能学到很多东西。</p>
<p>总的来说SDWebImage的加载策略非常直观，首先请求内存是否有URL对应的图片，如果没有就查找磁盘中的缓存；<br>如果缓存中都没有的话发起请求异步加载图片（当然加载的过程，设置还有对应的回调是最精髓的地方），将请求加入到待执行的请求队列中，一个个执行。直到异步加载成功之后，执行completion回调，缓存新下载的图片并更新UI（如果需要的话）。</p>
<h4 id="补充说明：NSURLCache的执行策略"><a href="#补充说明：NSURLCache的执行策略" class="headerlink" title="补充说明：NSURLCache的执行策略"></a>补充说明：NSURLCache的执行策略</h4><p>上面有些地方忽略说明，因为很难一两句交代清楚，这里补充说明一下NSURLCache的缓存策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)</div><div class="line">&#123;</div><div class="line">    NSURLRequestUseProtocolCachePolicy = 0,</div><div class="line">    // 默认的缓存策略，由协议制定了最好的实现方式</div><div class="line"></div><div class="line">    NSURLRequestReloadIgnoringLocalCacheData = 1,</div><div class="line">    // 完全从服务器端加载数据，忽略本地缓存</div><div class="line">    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented</div><div class="line">    </div><div class="line">    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,</div><div class="line"></div><div class="line">    NSURLRequestReturnCacheDataElseLoad = 2,</div><div class="line">    // 使用缓存数据，忽略过期时间，只有在没有缓存版本的时候才从远端加载数据</div><div class="line">    </div><div class="line">    NSURLRequestReturnCacheDataDontLoad = 3,</div><div class="line">    // 只使用cache数据</div><div class="line"></div><div class="line">    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>根据官网的说明，应该遵循的流程如下：<br>(1) 如果请求的缓存响应不存在，直接从源加载数据<br>(2) 如果存在，查看是否每次需要重新验证，如果不是响应的缓存的过期则直接加载缓存数据<br>(3) 如果缓存的响应过期或者需要重新验证，URL加载系统发送HEAD请求到源，查看是否需要抓取新的响应<br>(4) 如果需要就重新请求，如果不需要就直接返回缓存的数据</p>
<p>前面提到的源码中调用了NSURLRequestCachePolicy的大致逻辑就是如此。</p>
<h4 id="总结SDWebImage的流程"><a href="#总结SDWebImage的流程" class="headerlink" title="总结SDWebImage的流程"></a>总结SDWebImage的流程</h4><p>SDWebImage中一般调用sd_setImageWithURL:placeholderImage:这个方法，最终它会调用一个需要progressBlock,completionBlock的方法。</p>
<p>然后获取SDWebImageManager中的单例调用一个downloadImageWithURL:…方法来获取图片，先查找魂村中的记录，以URL作为索引，顺序是先查找缓存然后查找磁盘中的数据，如果有就直接使用。如果都没有那么manager就会调用加载图片的方法downloadImageWithURL:来从网络获取图片，它会调用另一个addProgressCallback:andCompletedBlock:URL:createCallback:来存储progress和completed的回调block，第一次添加时会实例化NSMutableURLRequest和SDWebImageDownloaderOperation,然后将operation加入下载队列开始异步加载，下载完成后使用图片。</p>
<p>本身倒是挺通俗易懂的。</p>

                
<p class="pink-link-context">
    <a href="/2017/07/02/Objective-c中的runtime学习记录/" rel="next" title="Objective-c中的runtime学习记录">
    Prev: Objective-c中的runtime学习记录
  </a>
</p>



<p class="pink-link-context">
    <a href="/2017/07/02/GCD总结/" rel="next" title="GCD概要">
    Next: GCD概要
  </a>
</p>


            </div>
			
        </div>
    </div>
</article>






</div>

        <div class="fixed-action-btn float-sitemap">
    <a class="btn-floating btn-large pink">
      <i class="fa fa-caret-square-o-up"></i>
    </a>
    <ul>
      <li><a class="btn-return-top btn-floating waves-effect green" title="Return to top"><i class="fa fa-arrow-circle-o-up"></i></a></li>
      <li><a class="btn-floating waves-effect button-collapse yellow darken-1"  data-activates="main-menu" title="Menu"><i class="fa fa-navicon"></i></a></li>
    </ul>
  </div>

    </main>
    <footer class="page-footer indigo darken-1">
    
    <div class="footer-container container">
        <div class="row">
            
            <div class="social-group col m4 s12">
                <h5 class="white-text">Social</h5>
                
                    <a class="social-link" href="http://weibo.com/1956184117" target="_blank">
                        <i class="fa fa-2x fa-weibo"></i>
                    </a>
                
                    <a class="social-link" href="https://github.com/raytaylorlin" target="_blank">
                        <i class="fa fa-2x fa-github"></i>
                    </a>
                
                    <a class="social-link" href="/atom.xml" target="_blank">
                        <i class="fa fa-2x fa-rss"></i>
                    </a>
                
                
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <div class="site-visitors-container white-text">
        <span>
            <i class="fa fa-user"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
        </span>
        <span>&nbsp;|&nbsp;</span>
        <span>
            <i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
        </span>
    </div>


            </div>
            

            
            <div class="col m8 s12">
                <h5 class="white-text">Links</h5>
                
                    <a class="social-link" href="http://raytaylorlin.com/" target="_blank">raytaylorism主题作者的技术博客</a>
                
                    <a class="social-link" href="https://github.com/raytaylorlin" target="_blank">Github地址（测试友情链接）</a>
                
            </div>
            
        </div>
    </div>
    

    <div class="footer-copyright pink-link-context">
        <div class="container">
            © 2016 example.com, All rights reserved.
            <p class="right" style="margin-top: 0;">Blog powered by <a href="https://hexo.io">Hexo</a> | Theme <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a></p>
        </div>
    </div>
</footer>


    <noscript>
    <div class="noscript">
        <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
    </div>
</noscript>
<div class="noscript">
    <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
</div>


<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>

<script>
    (function($) {
        $(document).ready(function() {
            // 隐藏禁用javascript（针对微信内置浏览器）的提示
            $('.noscript').hide();

            // 图片缩放效果
            var $imgs = $('img').not('.slider-image').not('.avatar-image').not('.carousel-image').not('.card-cover-image').not('.qrcode');

            // 给图片加上点击放大效果（materialbox插件）
            $imgs.addClass('materialboxed').each(function(i, el) {
                $(this).attr('data-caption', $(this).attr('alt') || ' ');
            }).materialbox();

            // 优化表格的显示
            $('table').each(function() {
                var $table = $(this);
                // 除去多行代码的情况
                if ($table.find('pre').length == 0) {
                    $table.addClass('responsive-table striped bordered');
                }
            });

            // 首页幻灯片
            $('.slider').slider({indicators: true, full_width: true, interval: 8000});

            $(".button-collapse").sideNav();
            $(".category-menu").sideNav();

            // 针对gallery post
            $('.carousel').carousel({full_width: true});
            $('.carousel-control.prev').click(function() {
                $('.carousel').carousel('prev');
            });
            $('.carousel-control.next').click(function() {
                $('.carousel').carousel('next');
            });

            // 文章目录
            $('article').not('.simple-article').find('h1').add('h2').add('h3').add('h4').add('h5').add('h6').scrollSpy();

            // 目录随屏幕滚动（防止目录过长越过footer）
            var $toc = $('.toc');
            var scrollTargetTop = 0;
            $(window).scroll(function() {
                var $activeLink = $toc.find('a.active.section');
                if ($(window).scrollTop() < 100) {
                    scrollTargetTop = 0;
                } else {
                    if ($activeLink[0]) {
                        scrollTargetTop = $activeLink.offset().top - $toc.offset().top;
                    }
                }
                $toc.css('top', '-' + scrollTargetTop + 'px');
            });

            // 修正文章目录的left-border颜色
            var color = $('.table-of-contents-text').css('color');
            $('.table-of-contents-link').css('border-left-color', color);

            // 针对移动端做的优化：FAB按钮点击一下收回
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                $('.fixed-action-btn').addClass('click-to-toggle');
            }
            // 回到顶部
            $('.btn-return-top').click(function() {
                $('body, html').animate({
                    scrollTop: 0
                }, 500);
            });

            // 重置读书页面的Tab标签页的颜色
            $('li.tab a').hover(function() {
                $(this).toggleClass('text-lighten-4');
            });
            $('.indicator').addClass('pink lighten-2');

            
            // 添加new标签
            $('.menu-reading, .menu-about').append('<span class="new badge pink"></span>');
            

            // 搜索功能
            $('.modal-trigger').leanModal({
                // 打开搜索框时自动聚焦
                ready: function() {
                    if ($('#search').is(":visible")) {
                        $('#search-input').focus();
                    }
                }
            });
            var searchXml = "";
            if (searchXml.length == 0) {
             	searchXml = "search.xml";
            }
            var searchPath = "/" + searchXml;
            initSearch(searchPath, 'search-input', 'search-result');
        });

        // 初始化搜索与匹配函数
        var initSearch = function(path, search_id, content_id) {
            'use strict';
            $.ajax({
                url: path,
                dataType: "xml",
                success: function(xmlResponse) {
                    // get the contents from search data
                    var datas = $("entry", xmlResponse).map(function() {
                        return {
                            title: $("title", this).text(),
                            content: $("content", this).text(),
                            url: $("url", this).text()
                        };
                    }).get();
                    var $input = document.getElementById(search_id);
                    var $resultContent = document.getElementById(content_id);
                    $input.addEventListener('input', function() {
                        var str = '<ul class=\"search-result-list\">';
                        var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                        $resultContent.innerHTML = "";
                        if (this.value.trim().length <= 0) {
                            return;
                        }
                        // perform local searching
                        datas.forEach(function(data) {
                            var isMatch = true;
                            var content_index = [];
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty titles and contents
                            if (data_title != '' && data_content != '') {
                                keywords.forEach(function(keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);
                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            }
                            // show search results
                            if (isMatch) {
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    data_title = data_title.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                });

                                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 100 characters
                                    var start = first_occur - 20;
                                    var end = first_occur + 80;
                                    if (start < 0) {
                                        start = 0;
                                    }
                                    if (start == 0) {
                                        end = 100;
                                    }
                                    if (end > content.length) {
                                        end = content.length;
                                    }
                                    var match_content = content.substring(start, end);
                                    // highlight all keywords
                                    keywords.forEach(function(keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                    });

                                    str += "<p class=\"search-result\">..." + match_content + "...</p>"
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        $resultContent.innerHTML = str;
                    });
                }
            });
        }
    })(jQuery);
</script>


<script src="/js/prettify.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        prettyPrint();
    });
</script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" async
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



</body>
</html>
